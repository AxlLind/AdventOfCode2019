use std::collections::HashSet;
use itertools::Itertools;
use num_integer::gcd;

static INPUT: [&str; 33] = [
  "..#..###....#####....###........#",
  ".##.##...#.#.......#......##....#",
  "#..#..##.#..###...##....#......##",
  "..####...#..##...####.#.......#.#",
  "...#.#.....##...#.####.#.###.#..#",
  "#..#..##.#.#.####.#.###.#.##.....",
  "#.##...##.....##.#......#.....##.",
  ".#..##.##.#..#....#...#...#...##.",
  ".#..#.....###.#..##.###.##.......",
  ".##...#..#####.#.#......####.....",
  "..##.#.#.#.###..#...#.#..##.#....",
  ".....#....#....##.####....#......",
  ".#..##.#.........#..#......###..#",
  "#.##....#.#..#.#....#.###...#....",
  ".##...##..#.#.#...###..#.#.#..###",
  ".#..##..##...##...#.#.#...#..#.#.",
  ".#..#..##.##...###.##.#......#...",
  "...#.....###.....#....#..#....#..",
  ".#...###..#......#.##.#...#.####.",
  "....#.##...##.#...#........#.#...",
  "..#.##....#..#.......##.##.....#.",
  ".#.#....###.#.#.#.#.#............",
  "#....####.##....#..###.##.#.#..#.",
  "......##....#.#.#...#...#..#.....",
  "...#.#..####.##.#.........###..##",
  ".......#....#.##.......#.#.###...",
  "...#..#.#.........#...###......#.",
  ".#.##.#.#.#.#........#.#.##..#...",
  ".......#.##.#...........#..#.#...",
  ".####....##..#..##.#.##.##..##...",
  ".#.#..###.#..#...#....#.###.#..#.",
  "............#...#...#.......#.#..",
  ".........###.#.....#..##..#.##...",
];
static H: i64 = INPUT.len() as i64;
static W: i64 = INPUT[0].len() as i64;

fn map_to_astroid_coords() -> HashSet<(i64,i64)> {
  INPUT.iter()
    .enumerate()
    .flat_map(|(i,s)| s.chars()
      .enumerate()
      .filter(|&(_,c)| c != '.')
      .map(|(j,_)| (i as i64, j as i64))
      .collect_vec()
    )
    .collect::<HashSet<_>>()
}

fn all_line_slopes() -> Vec<(i64,i64)> {
  let (x_max, y_max) = (H-1,W-1);
  (-x_max..x_max)
    .cartesian_product(-y_max..y_max)
    .filter(|&(x,y)| gcd(x,y) == 1)
    .collect_vec()
}

fn main() {
  let asteroids = map_to_astroid_coords();
  let slopes = all_line_slopes();
  let answer = asteroids.iter()
    .map(|&(x,y)| slopes.iter()
      .filter(|(dx,dy)| {
        let (mut new_x, mut new_y) = (x+dx,y+dy);
        loop {
          if new_x >= H || new_x < 0 { return false; }
          if new_y >= W || new_y < 0 { return false; }
          if asteroids.contains(&(new_x, new_y)) {
            return true;
          }
          new_x += dx;
          new_y += dy;
        }
      })
      .count()
    )
    .max();
  println!("{}", answer.unwrap());
}
